# Python Simplified Grammar (Updated to match parser.cpp implementation)

program: statement*

# === STATEMENTS ===

statement: if_stmt
         | while_stmt
         | for_stmt
         | funcdef
         | class_def
         | return_stmt
         | pass_stmt
         | break_stmt
         | continue_stmt
         | import_stmt
         | assignment
         | function_call_stmt
         | expression_stmt

# === SIMPLE STATEMENTS ===

pass_stmt: 'pass'
break_stmt: 'break'
continue_stmt: 'continue'
return_stmt: 'return' [test]

import_stmt: 'import' dotted_name ('as' NAME)? (',' dotted_name ('as' NAME)?)*
           | 'from' dotted_name 'import' (NAME ('as' NAME)? | '*')

dotted_name: NAME ('.' NAME)*

assignment: identifier_list assign_op (expression_list | test)
identifier_list: (NAME | attribute_access) (',' NAME)*
expression_list: test (',' test)*

assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '//='

function_call_stmt: (NAME | dotted_name) '(' [arguments] ')'
arguments: test (',' test)* [',']

expression_stmt: test

# === COMPOUND STATEMENTS ===

if_stmt: 'if' test ':' suite
         ('elif' test ':' suite)*
         ['else' ':' suite]

while_stmt: 'while' test ':' suite

for_stmt: 'for' NAME 'in' test ':' suite

funcdef: 'def' NAME '(' [parameters] ')' ':' suite
parameters: NAME (',' NAME)*

class_def: 'class' NAME ['(' NAME ')'] ':' suite

suite: statement
     | NEWLINE INDENT statement+ DEDENT

# === EXPRESSIONS ===

test: ternary_op

ternary_op: or_test ['if' or_test 'else' test]

or_test: and_test ('or' and_test)*
and_test: not_test ('and' not_test)*
not_test: 'not' not_test | comparison

comparison: arith_expr [comp_op arith_expr]
comp_op: '<' | '>' | '==' | '>=' | '<=' | '!='

arith_expr: term (('+' | '-') term)*
term: factor (('*' | '/' | '//') factor)*

factor: ('+' | '-' | '~') factor
      | atom_expr

atom_expr: atom trailer*
trailer: '(' [arguments] ')'
       | '.' NAME

# === ATOMS ===

atom: '(' [test (',' test)*] ')'  # Tuple or parenthesized expression
    | '[' [test (',' test)*] ']'  # List
    | '{' [key_value_pair (',' key_value_pair)*] '}'  # Dict
    | NAME
    | NUMBER
    | STRING
    | 'None' | 'True' | 'False'

key_value_pair: test ':' test

attribute_access: atom_expr '.' NAME

# === LITERALS ===

NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+(\.[0-9]+)?/
STRING: /'(\\.|[^'])*'|"(\\.|[^"])*"/
NEWLINE: /(\r?\n)+/
INDENT: '<INDENT>'
DEDENT: '<DEDENT>'
ENDMARKER: '<EOF>'